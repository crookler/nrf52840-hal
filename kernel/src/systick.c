/** @file   systick.c
 *  @brief  Implementation of generic SysTick counter configuration
**/

#include "systick.h"
#include "error.h"
#include "printk.h"
#include "multitask.h"

/// Number of times that the timer has counted from the reset value down to 0
uint8_t timer_wrap_around;

/// Number of times that the timer needs to wrap before it can do its main functionality
uint8_t timer_wrap_comparison;

/**
 * Configure SysTick counter with new reload value, clksource (either internal or external), and interrupt generation status.
 * Returns error code on invalid args and 0 otherwise.
 */
int systick_configure(uint32_t reload, systick_clksource clksource, systick_tickint tickint) {
    volatile systick_t* counter = (volatile systick_t *)SYSTICK_BASE_ADDR;
    counter->CSR = SystickDisabled; // Disable counter to apply new configuration
    counter->CSR =  SYSTICK_CSR_CONFIG_VAL(clksource, tickint);

    // Check if reload value is valid and if not return error code
    if (reload > MAX_24_BIT) {
        return SYSTICK_INVALID_ARG;
    }
    counter->RVR = reload;
    counter->CVR = 0; // Write to reset CVR to 0
    counter->CSR |= SystickEnabled; // Enable peripheral after configuration is finished (but do not overwrite old bits)
    return SUCCESS;
}

/**
 * Wrapper function for disabling the SysTick timer.
 * Only an additional call to systick_configure can re-enable the timer.
 */
void systick_disable() {
    volatile systick_t* counter = (volatile systick_t *)SYSTICK_BASE_ADDR;
    counter->CSR = SystickDisabled; // No or so the timer does not stay enabled
}

/**
 * Uses the SysTick timer to conduct a blocking wait for `ms` milliseconds.
 * Returns after the provided number of `ms` have elapsed.
 * Uses a double looped structure to perform repeated 1 ms waits in a loop.
 */
void systick_delay(uint32_t ms) {
    // Initialize ticks and systick struct (with configuration registers)
    uint32_t ticks = 0;
    systick_t *systick = (systick_t *)SYSTICK_BASE_ADDR;

    // Disable systick timer and configure (then re-enable)
    systick->CSR = 0;
    systick->CVR = 1;
    systick->RVR = 63999;
    systick->CSR = (1 << 0) | (1 << 2);

    // Busy wait until enough ticks have elapsed to equal ms
    while(ticks < ms) {
        while(!(systick->CSR & (1 << 16)));
        ticks++;
    }
    systick->CSR = 0; // Distable at end
}

/**
 * Handles the SysTick exception generated by the SysTick counter when the current value reaches 0.
 * Modifies global variables relating to the number of times that the counter has reached 0. 
 * Performs scheduling (via setting PendSV to high) on every timer_wrap_comparison'th invocation of the handler (i.e. the actual scheduling does not happen until timer_wrap_around equals the timer_wrap_comparison)
 */
void SysTick_Handler() {
    // Reset to 0 if this is the timer_wrap_comparison'th wrap (starting at 1)
    // Assert the preempt flag to say that this scheduling decision was made made by this interrupt (and not voluntary yielding or ending)
    if (timer_wrap_around == timer_wrap_comparison) {
        timer_wrap_around = 1;
        preemption_flag = 1;
        set_pendsv(); // Set pendsv handler bit after the correct number of invocations
    } else {
        timer_wrap_around++;
    }
}