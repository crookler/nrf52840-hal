<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded from Scratch: multitask.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded from Scratch
   &#160;<span id="projectnumber">Project</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('multitask_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">multitask.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores syscall function prototypes and kernel level structs for managing inter-process states.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="arm_8h_source.html">arm.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="thread_8h_source.html">thread.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mpu_8h_source.html">mpu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mutex_8h_source.html">mutex.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for multitask.h:</div>
<div class="dyncontent">
<div class="center"><img src="multitask_8h__incl.png" border="0" usemap="#amultitask_8h" alt=""/></div>
<map name="amultitask_8h" id="amultitask_8h">
<area shape="rect" title="Stores syscall function prototypes and kernel level structs for managing inter&#45;process states." alt="" coords="45,5,141,32"/>
<area shape="rect" href="arm_8h.html" title="Macro definitions, typedefs, and aliases for common ARM functionality." alt="" coords="70,229,130,256"/>
<area shape="rect" href="thread_8h.html" title="Common ethread structs and constants needed according source files aiding with mulititasking." alt="" coords="24,155,100,181"/>
<area shape="rect" href="mpu_8h.html" title="MMIO addresses and common enums/structs for working with the memory protection unit." alt="" coords="176,155,239,181"/>
<area shape="rect" href="mutex_8h.html" title="Provides stubs and data structures for implementing mutual exclusion." alt="" coords="94,80,170,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="multitask_8h__dep__incl.png" border="0" usemap="#amultitask_8hdep" alt=""/></div>
<map name="amultitask_8hdep" id="amultitask_8hdep">
<area shape="rect" title="Stores syscall function prototypes and kernel level structs for managing inter&#45;process states." alt="" coords="146,5,242,32"/>
<area shape="rect" href="mpu_8c.html" title="Helper functions for managing the MPU and using its peripheral registers in the SCS." alt="" coords="5,80,68,107"/>
<area shape="rect" href="multitask_8c.html" title="Implementation of SVC handlers associated with multithreading." alt="" coords="92,80,187,107"/>
<area shape="rect" href="syscall_8c.html" title="Implementation of SVC handler allowing for generic software&#45;pended exceptions and select NEWLIB requi..." alt="" coords="211,80,289,107"/>
<area shape="rect" href="systick_8c.html" title="Implementation of generic SysTick counter configuration." alt="" coords="313,80,392,107"/>
</map>
</div>
</div>
<p><a href="multitask_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25cde7ce3d60ab7047be78e3026af797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a25cde7ce3d60ab7047be78e3026af797">schedule_rms</a> ()</td></tr>
<tr class="separator:a25cde7ce3d60ab7047be78e3026af797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754f449056971915a16c171782ac13e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#ab754f449056971915a16c171782ac13e">syscall_multitask_request</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_threads, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> stack_bytes, void *idle_function, <a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a> mpu_protect, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_locks)</td></tr>
<tr class="separator:ab754f449056971915a16c171782ac13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f0f782b4f394e88e777f77833eb2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a0b2f0f782b4f394e88e777f77833eb2e">syscall_thread_define</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> id, void *fn, void *arg, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> c, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> t)</td></tr>
<tr class="separator:a0b2f0f782b4f394e88e777f77833eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc9ee772b1653c779ac03c6cc73b64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a9acc9ee772b1653c779ac03c6cc73b64">syscall_multitask_start</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> freq)</td></tr>
<tr class="separator:a9acc9ee772b1653c779ac03c6cc73b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e7f05531ce77a0eaeaf9986a1681ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a97e7f05531ce77a0eaeaf9986a1681ab">syscall_thread_id</a> ()</td></tr>
<tr class="separator:a97e7f05531ce77a0eaeaf9986a1681ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca0cb20d7a90459730e324d4e482cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a1ca0cb20d7a90459730e324d4e482cdc">syscall_thread_yield</a> ()</td></tr>
<tr class="separator:a1ca0cb20d7a90459730e324d4e482cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e4b23c571c2d9d179b4ba0b7900e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a866e4b23c571c2d9d179b4ba0b7900e6">syscall_thread_end</a> ()</td></tr>
<tr class="separator:a866e4b23c571c2d9d179b4ba0b7900e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fab2995bbed7e15135fc27ca47d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a359fab2995bbed7e15135fc27ca47d57">syscall_get_time</a> ()</td></tr>
<tr class="separator:a359fab2995bbed7e15135fc27ca47d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c45004b0a0a1c6421e48172dc7c95d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a0c45004b0a0a1c6421e48172dc7c95d9">syscall_thread_time</a> ()</td></tr>
<tr class="separator:a0c45004b0a0a1c6421e48172dc7c95d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88181cd9837806cda58242c3a12fc49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#ab88181cd9837806cda58242c3a12fc49">syscall_thread_priority</a> ()</td></tr>
<tr class="separator:ab88181cd9837806cda58242c3a12fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754c1689a7e5276a2089a20f0463a7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a754c1689a7e5276a2089a20f0463a7e1">syscall_lock_init</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> prio)</td></tr>
<tr class="separator:a754c1689a7e5276a2089a20f0463a7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499ff3d48a2ff684d62e45eb5ce345dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a499ff3d48a2ff684d62e45eb5ce345dc">syscall_lock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="separator:a499ff3d48a2ff684d62e45eb5ce345dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb893fb41e034375ed68df5b52b9a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#adfb893fb41e034375ed68df5b52b9a51">syscall_unlock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="separator:adfb893fb41e034375ed68df5b52b9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8a6d27b56fad7c687915357337ccac3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtcb__t.html">tcb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a8a6d27b56fad7c687915357337ccac3d">user_threads</a> [<a class="el" href="thread_8h.html#a5747ce5beae65002b9ee2c4a4cf8c329">MAX_NUM_THREADS</a>+2]</td></tr>
<tr class="memdesc:a8a6d27b56fad7c687915357337ccac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of TCB's of threads specificed by user.  <a href="multitask_8h.html#a8a6d27b56fad7c687915357337ccac3d">More...</a><br /></td></tr>
<tr class="separator:a8a6d27b56fad7c687915357337ccac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7b71344d29c1a1eb33dcedd570f11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#afe7b71344d29c1a1eb33dcedd570f11a">num_user_threads</a></td></tr>
<tr class="memdesc:afe7b71344d29c1a1eb33dcedd570f11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of active threads that the user specified (cannot be greater than MAX_NUM_THREADS)  <a href="multitask_8h.html#afe7b71344d29c1a1eb33dcedd570f11a">More...</a><br /></td></tr>
<tr class="separator:afe7b71344d29c1a1eb33dcedd570f11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#ae2cec55f1b89b2feec90fa920ef1e48c">num_active_threads</a></td></tr>
<tr class="memdesc:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads that are still active from what the user initially specified.  <a href="multitask_8h.html#ae2cec55f1b89b2feec90fa920ef1e48c">More...</a><br /></td></tr>
<tr class="separator:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a5cf4e2c768a73eaec2ffaa193b050b80">active_thread_index</a></td></tr>
<tr class="memdesc:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active index of the thread in user_thread.  <a href="multitask_8h.html#a5cf4e2c768a73eaec2ffaa193b050b80">More...</a><br /></td></tr>
<tr class="separator:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de4813a04b35d0e889c32deba62359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a51de4813a04b35d0e889c32deba62359">global_timeslot_counter</a></td></tr>
<tr class="memdesc:a51de4813a04b35d0e889c32deba62359"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current timeslot that the scheduler is using since program start.  <a href="multitask_8h.html#a51de4813a04b35d0e889c32deba62359">More...</a><br /></td></tr>
<tr class="separator:a51de4813a04b35d0e889c32deba62359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789a56d621057f7249eced42d4039fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a789a56d621057f7249eced42d4039fd9">preemption_flag</a></td></tr>
<tr class="memdesc:a789a56d621057f7249eced42d4039fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for determining the source of the schedulign decision (asserted when scheduling is performed from systick timer)  <a href="multitask_8h.html#a789a56d621057f7249eced42d4039fd9">More...</a><br /></td></tr>
<tr class="separator:a789a56d621057f7249eced42d4039fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2115ccd92943e1b183dae612bb2a29"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a9d2115ccd92943e1b183dae612bb2a29">total_utilization</a></td></tr>
<tr class="memdesc:a9d2115ccd92943e1b183dae612bb2a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain the utilization of the currently active task set (used in admission control)  <a href="multitask_8h.html#a9d2115ccd92943e1b183dae612bb2a29">More...</a><br /></td></tr>
<tr class="separator:a9d2115ccd92943e1b183dae612bb2a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275005d5849e9f3f95cd318e073bad28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a275005d5849e9f3f95cd318e073bad28">user_locks</a> [<a class="el" href="thread_8h.html#a4736b40a365c5ea2579fbf37eeaac2db">MAX_USER_LOCKS</a>]</td></tr>
<tr class="memdesc:a275005d5849e9f3f95cd318e073bad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of locks for coordination between user threads.  <a href="multitask_8h.html#a275005d5849e9f3f95cd318e073bad28">More...</a><br /></td></tr>
<tr class="separator:a275005d5849e9f3f95cd318e073bad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424a5e8583f9ff3795f8ec79211922a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#af424a5e8583f9ff3795f8ec79211922a">num_user_locks</a></td></tr>
<tr class="memdesc:af424a5e8583f9ff3795f8ec79211922a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of locks requested by the user application.  <a href="multitask_8h.html#af424a5e8583f9ff3795f8ec79211922a">More...</a><br /></td></tr>
<tr class="separator:af424a5e8583f9ff3795f8ec79211922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97ea800d90c5f2c81478f725be69b49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#ad97ea800d90c5f2c81478f725be69b49">num_defined_locks</a></td></tr>
<tr class="memdesc:ad97ea800d90c5f2c81478f725be69b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of locks already defined by the user application (should not exceed num_user_locks)  <a href="multitask_8h.html#ad97ea800d90c5f2c81478f725be69b49">More...</a><br /></td></tr>
<tr class="separator:ad97ea800d90c5f2c81478f725be69b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123498dea62575b7d38c997864aeecb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a123498dea62575b7d38c997864aeecb3">global_priority_ceiling</a></td></tr>
<tr class="memdesc:a123498dea62575b7d38c997864aeecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current priority ceiling for user tasks (i.e. the maximum priority ceiling for all currently held locks)  <a href="multitask_8h.html#a123498dea62575b7d38c997864aeecb3">More...</a><br /></td></tr>
<tr class="separator:a123498dea62575b7d38c997864aeecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2bd4f223a6174ea8aff14e4f44770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8h.html#a51a2bd4f223a6174ea8aff14e4f44770">highest_priority_lock</a></td></tr>
<tr class="memdesc:a51a2bd4f223a6174ea8aff14e4f44770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of the lock that currently is dictating the global_priority_ceiling (i.e. the lock who set the current global priority ceiling equal to its priority ceiling)  <a href="multitask_8h.html#a51a2bd4f223a6174ea8aff14e4f44770">More...</a><br /></td></tr>
<tr class="separator:a51a2bd4f223a6174ea8aff14e4f44770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores syscall function prototypes and kernel level structs for managing inter-process states. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a25cde7ce3d60ab7047be78e3026af797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cde7ce3d60ab7047be78e3026af797">&#9670;&nbsp;</a></span>schedule_rms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> schedule_rms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next thread id that will be scheduled (from currently active threads) using a rate-monotonic scheduler</p>
<p>Scheduling policy using RMS that returns the index in the user_threads array of the next task to be scheduled. Sweeps through the user_threads array and determines the highest priority task (including the idle thread) that is ready to run. Also performs bookkeeping related to maintaining the number of scheduling cycles until a waiting task can be made ready again (i.e. only consider tasks that are ThreadReady but change thread from ThreadWaiting to ThreadReady when time_until_release = 0). Maintain periodic behavior by incrementing time_until_release by thread period every time it equals 0 and by decrementing remaining_work for every cycle the current task is scheduled (reset to computation time upon reaching 0). </p>

</div>
</div>
<a id="a359fab2995bbed7e15135fc27ca47d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fab2995bbed7e15135fc27ca47d57">&#9670;&nbsp;</a></span>syscall_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for getting the up-time of the system (number of scheduling periods that have passed)</p>
<p>A call to this function represents the time that a task occupied rather than the raw number of decisions made as a result of timer preemption. The counter is treated as the absolute source of truth and represents the time after multitask_start initially invokes the scheduler (so counter == 0 implies the scheduler is working on timeslot 0). Timeslot is only incremented when a systick timer interrupt fires (to keep global_timeslot_counter in time with the number of scheduling decisions). </p>

</div>
</div>
<a id="a499ff3d48a2ff684d62e45eb5ce345dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499ff3d48a2ff684d62e45eb5ce345dc">&#9670;&nbsp;</a></span>syscall_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for locking a lock with the opaque address <code>m</code> (will be of a different type at user level but maps to a <a class="el" href="structmutex__t.html">mutex_t</a> struct at kernel level)</p>
<p>Blocking system call for a user application to request control of a lock. Locks requests are granted / denied according to the original priority ceiling protocol (see interior comments for details about what this implies). Will not return until the lock has been acquired. Since this syscall is blocking, it is guranteed that any thread will only be waiting on a maximum of 1 lock. </p>

</div>
</div>
<a id="a754c1689a7e5276a2089a20f0463a7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754c1689a7e5276a2089a20f0463a7e1">&#9670;&nbsp;</a></span>syscall_lock_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a>* syscall_lock_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for initializing a lock (kernel must already have defined empty structs for mutexes by the time this function is called from user space) with an additional parameter to specify the highest locker ID <code>prio</code></p>
<p>Checks if there is space to initialize a new mutex. If it can be accomodated, a new mutex from the free batch in user_locks is initialized, and its address is returned. The <code>prio</code> field is the thread ID of the user thread whose static priority should be set as highest_priority. There is no gurantee that this function will be called after thread define, so must validate the ID in multitask_start (i.e. before the thing is actually scheduled) </p>

</div>
</div>
<a id="ab754f449056971915a16c171782ac13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab754f449056971915a16c171782ac13e">&#9670;&nbsp;</a></span>syscall_multitask_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_multitask_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>stack_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a>&#160;</td>
          <td class="paramname"><em>mpu_protect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>num_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall requesting the paritioning of kernel and user stack space for multiple threads (<code>num_threads</code> pieces each with both process and main stack size of <code>stack_bytes</code>) and specifies an optional <code>idle_function</code> for when no other tasks are schedulable Also specifies the number of locks that have be used by the user application.</p>
<p>Returns an error code if the allocated space of the request would be larger than 32kB of stack space (or if the number of threads exceeds 14) Otherwise, this implementation sets up the requested stacks by taking slices starting from the base addresses (i.e. stack pointer decreasing from the base_addr - growing down for each num_thread). Transforms the request <code>stack_bytes</code> into the next highest power of 2 (ceiling) so that the stacks stay well aligned and behaved. This transformation may result in a rejection of parameters if they are at (but not exactly at the limit) of stack space (i.e. would not be rejected without rounding). Also configures memory regions to prevent unwanted access according to <code>mpu_protect</code> policy. Additionally initializes empty <a class="el" href="structmutex__t.html">mutex_t</a> structs in the global <code>user_locks</code> (one empty struct per num_locks specified by user) </p>

</div>
</div>
<a id="a9acc9ee772b1653c779ac03c6cc73b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acc9ee772b1653c779ac03c6cc73b64">&#9670;&nbsp;</a></span>syscall_multitask_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_multitask_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall specifying the frequency of the scheduling call (with a call with zero being interpretted as a non-preemptive scheduler - i.e. the scheduler will not run unless a task explicitly yields)</p>
<p>Configures the SysTick timer to fire with interrupts as fast as 1 second (a frequency of zero of implies that the scheduler is not-preemptive and will only be invoked through explicit). Starts the SysTick timer to begin counting down (with the scheduling decision being pended directly from the SysTick timer handler). This function call is not again scheduled until all other user threads have terminated (i.e. joins the threads) and stops the SysTick timer when all threads have terminated. </p>

</div>
</div>
<a id="a0b2f0f782b4f394e88e777f77833eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2f0f782b4f394e88e777f77833eb2e">&#9670;&nbsp;</a></span>syscall_thread_define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_thread_define </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall spawning a thread that asynchronously executes the given <code>fn</code> with an optional <code>arg</code> and a given <code>id</code> (id must be unique for thread to spawn) along with periodic behavior given by worst-case execution time <code>c</code> and period <code>t</code></p>
<p>Performs admission control and parameter validation on the inputted arguements. Overwrites the "dummy" TCB created in multitask_request with the parameter id, async function, and periodic data needed for scheduling. Returns a negative error code if the task cannot be safely accepted, but otherwise accepts the task and places it in an empty location in the user_threads array. </p>

</div>
</div>
<a id="a866e4b23c571c2d9d179b4ba0b7900e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e4b23c571c2d9d179b4ba0b7900e6">&#9670;&nbsp;</a></span>syscall_thread_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_thread_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for suspending the currently running thread (does not make end syscall with infinite loop trap)</p>
<p>Immediately invokes the scheduler and labels the current thread as having exited (i.e. will not be scheduled). The dead TCB for this thread will still exist in the user_threads array and can be overwritten with a new definition now that this TCB is defunct. Decrements the number of active threads to allow the scheduler to schedule the main thread if all others have ended. Also cleans up the <code>user_threads</code> array to allow non-defunct threads to take the place Additionally releases any locks which the ending thread may currently possess </p>

</div>
</div>
<a id="a97e7f05531ce77a0eaeaf9986a1681ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e7f05531ce77a0eaeaf9986a1681ab">&#9670;&nbsp;</a></span>syscall_thread_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for returning the thread id of the currently running thread</p>
<p>Return the ID field of the TCB for the currently running thread. </p>

</div>
</div>
<a id="ab88181cd9837806cda58242c3a12fc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88181cd9837806cda58242c3a12fc49">&#9670;&nbsp;</a></span>syscall_thread_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for returning the priority of the the current thread</p>
<p>Return the static priority of the currently running task. This is determined by the period parameter (with a lower period indiciating a higher priorty) unless a special priority has been assigned manually (such as the case of the idle task or priority inheritance) </p>

</div>
</div>
<a id="a0c45004b0a0a1c6421e48172dc7c95d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c45004b0a0a1c6421e48172dc7c95d9">&#9670;&nbsp;</a></span>syscall_thread_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for returning the number of scheduling cycles that this thread has been active for</p>
<p>Return the active time for the current thread. The active time is the number of scheduling cycles that the thread has been running (i.e. number of times the thread has been scheduled) </p>

</div>
</div>
<a id="a1ca0cb20d7a90459730e324d4e482cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca0cb20d7a90459730e324d4e482cdc">&#9670;&nbsp;</a></span>syscall_thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_thread_yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for manually yielding the running thread and returning control to the scheduler</p>
<p>Manually pends the PendSV signal to immediately invoke the scheduler. Labels the current thread as waiting (i.e. not to be scheduled again until the start of the next period) Under current scheduler schemes, the thread could be immediately rescheduled if it is the only one remaining (or is it has the highest priority) </p>

</div>
</div>
<a id="adfb893fb41e034375ed68df5b52b9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb893fb41e034375ed68df5b52b9a51">&#9670;&nbsp;</a></span>syscall_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Syscall for unlocking a lock with the opaque address <code>m</code> (<a class="el" href="structlock__t.html">lock_t</a> at userlevel and <a class="el" href="structmutex__t.html">mutex_t</a> at kernel level)</p>
<p>System call for unlocking the provided mutex <code>m</code> (opaque at user level). Since threads are only waiting on a maximum of 1 lock (from above) and unlocks occur immediately (unconditionally), all threads waiting on this lock can immediately move to the ready state to contend for it again (those unsuccessful will go back to the blocked state). Once unlocked, the current mutex has its num_blocked_threads and current_locker field reset (to keep state consistent). After the mutex is unlocked, the new highest_priority_lck is determined, and the new prioriy of the running task is potentially changed to inherit a higher priority task's priority if it is blocking on a lock held by the current thread. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5cf4e2c768a73eaec2ffaa193b050b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf4e2c768a73eaec2ffaa193b050b80">&#9670;&nbsp;</a></span>active_thread_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> active_thread_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Active index of the thread in user_thread. </p>

</div>
</div>
<a id="a123498dea62575b7d38c997864aeecb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123498dea62575b7d38c997864aeecb3">&#9670;&nbsp;</a></span>global_priority_ceiling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> global_priority_ceiling</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current priority ceiling for user tasks (i.e. the maximum priority ceiling for all currently held locks) </p>

</div>
</div>
<a id="a51de4813a04b35d0e889c32deba62359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de4813a04b35d0e889c32deba62359">&#9670;&nbsp;</a></span>global_timeslot_counter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> global_timeslot_counter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current timeslot that the scheduler is using since program start. </p>
<p>The current timeslot that the scheduler is using since program start. </p>

</div>
</div>
<a id="a51a2bd4f223a6174ea8aff14e4f44770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2bd4f223a6174ea8aff14e4f44770">&#9670;&nbsp;</a></span>highest_priority_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a>* highest_priority_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Address of the lock that currently is dictating the global_priority_ceiling (i.e. the lock who set the current global priority ceiling equal to its priority ceiling) </p>

</div>
</div>
<a id="ae2cec55f1b89b2feec90fa920ef1e48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cec55f1b89b2feec90fa920ef1e48c">&#9670;&nbsp;</a></span>num_active_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_active_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads that are still active from what the user initially specified. </p>
<p>Number of threads that are still active from what the user initially specified. </p>

</div>
</div>
<a id="ad97ea800d90c5f2c81478f725be69b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97ea800d90c5f2c81478f725be69b49">&#9670;&nbsp;</a></span>num_defined_locks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_defined_locks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of locks already defined by the user application (should not exceed num_user_locks) </p>

</div>
</div>
<a id="af424a5e8583f9ff3795f8ec79211922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af424a5e8583f9ff3795f8ec79211922a">&#9670;&nbsp;</a></span>num_user_locks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_user_locks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of locks requested by the user application. </p>

</div>
</div>
<a id="afe7b71344d29c1a1eb33dcedd570f11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7b71344d29c1a1eb33dcedd570f11a">&#9670;&nbsp;</a></span>num_user_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_user_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of active threads that the user specified (cannot be greater than MAX_NUM_THREADS) </p>
<p>Number of active threads that the user specified (cannot be greater than MAX_NUM_THREADS) </p>

</div>
</div>
<a id="a789a56d621057f7249eced42d4039fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789a56d621057f7249eced42d4039fd9">&#9670;&nbsp;</a></span>preemption_flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> preemption_flag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for determining the source of the schedulign decision (asserted when scheduling is performed from systick timer) </p>
<p>Used for determining the source of the schedulign decision (asserted when scheduling is performed from systick timer) </p>

</div>
</div>
<a id="a9d2115ccd92943e1b183dae612bb2a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2115ccd92943e1b183dae612bb2a29">&#9670;&nbsp;</a></span>total_utilization</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float total_utilization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintain the utilization of the currently active task set (used in admission control) </p>
<p>Maintain the utilization of the currently active task set (used in admission control) </p>

</div>
</div>
<a id="a275005d5849e9f3f95cd318e073bad28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275005d5849e9f3f95cd318e073bad28">&#9670;&nbsp;</a></span>user_locks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a> user_locks[<a class="el" href="thread_8h.html#a4736b40a365c5ea2579fbf37eeaac2db">MAX_USER_LOCKS</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of locks for coordination between user threads. </p>

</div>
</div>
<a id="a8a6d27b56fad7c687915357337ccac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6d27b56fad7c687915357337ccac3d">&#9670;&nbsp;</a></span>user_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtcb__t.html">tcb_t</a> user_threads[<a class="el" href="thread_8h.html#a5747ce5beae65002b9ee2c4a4cf8c329">MAX_NUM_THREADS</a>+2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of TCB's of threads specificed by user. </p>
<p>Array of TCB's of threads specificed by user. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_009f605b833ac4622acd6c3c0c26c0f0.html">include</a></li><li class="navelem"><a class="el" href="multitask_8h.html">multitask.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
