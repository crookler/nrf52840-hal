<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded from Scratch: multitask.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded from Scratch
   &#160;<span id="projectnumber">Project</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('multitask_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">multitask.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of SVC handlers associated with multithreading.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="multitask_8h_source.html">multitask.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="syscall_8h_source.html">syscall.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="systick_8h_source.html">systick.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="error_8h_source.html">error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="printk_8h_source.html">printk.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for multitask.c:</div>
<div class="dyncontent">
<div class="center"><img src="multitask_8c__incl.png" border="0" usemap="#amultitask_8c" alt=""/></div>
<map name="amultitask_8c" id="amultitask_8c">
<area shape="rect" title="Implementation of SVC handlers associated with multithreading." alt="" coords="312,5,407,32"/>
<area shape="rect" href="multitask_8h.html" title="Stores syscall function prototypes and kernel level structs for managing inter&#45;process states." alt="" coords="122,80,218,107"/>
<area shape="rect" href="syscall_8h.html" title="Contains stubs and structs useful for handling the SVC handler and letting it support syscalls/additi..." alt="" coords="259,229,337,256"/>
<area shape="rect" href="systick_8h.html" title="Address locations and types for working with the SysTick timer." alt="" coords="362,229,442,256"/>
<area shape="rect" href="error_8h.html" title="Constants for unified error codes across all peripherals. Each error code specifies exactly one uniqu..." alt="" coords="397,80,461,107"/>
<area shape="rect" href="printk_8h.html" title="Prototypes for printk (print to debugger as a wrapper of rtt.h)" alt="" coords="485,80,557,107"/>
<area shape="rect" href="arm_8h.html" title="Macro definitions, typedefs, and aliases for common ARM functionality." alt="" coords="191,304,251,331"/>
<area shape="rect" href="thread_8h.html" title="Common ethread structs and constants needed according source files aiding with mulititasking." alt="" coords="56,229,132,256"/>
<area shape="rect" href="mpu_8h.html" title="MMIO addresses and common enums/structs for working with the memory protection unit." alt="" coords="208,155,271,181"/>
<area shape="rect" href="mutex_8h.html" title="Provides stubs and data structures for implementing mutual exclusion." alt="" coords="5,155,81,181"/>
<area shape="rect" href="rtt_8h.html" title="Function prototpyes and struct definitions for writing/reading to the up and down buffer of the debug..." alt="" coords="476,155,525,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4dd1e2f7f1c9da499a0a418f0b5b0495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a4dd1e2f7f1c9da499a0a418f0b5b0495">active_thread_holds_locks</a> ()</td></tr>
<tr class="separator:a4dd1e2f7f1c9da499a0a418f0b5b0495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016a482f23be8cd4f8ab1d328fdc45d7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a016a482f23be8cd4f8ab1d328fdc45d7">PendSV_C_Handler</a> (void *msp)</td></tr>
<tr class="separator:a016a482f23be8cd4f8ab1d328fdc45d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cde7ce3d60ab7047be78e3026af797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a25cde7ce3d60ab7047be78e3026af797">schedule_rms</a> ()</td></tr>
<tr class="separator:a25cde7ce3d60ab7047be78e3026af797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838007cda3d9a850381803edca1a15b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a838007cda3d9a850381803edca1a15b0">thread_end</a> ()</td></tr>
<tr class="memdesc:a838007cda3d9a850381803edca1a15b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">External user space declaration for making the svc call to thread_end (should be what is called when user space function end)  <a href="multitask_8c.html#a838007cda3d9a850381803edca1a15b0">More...</a><br /></td></tr>
<tr class="separator:a838007cda3d9a850381803edca1a15b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0db77f2d0178f08d9db4d25750fd1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a7b0db77f2d0178f08d9db4d25750fd1f">thread_function_define</a> (void *fn, void *arg, <a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> index)</td></tr>
<tr class="separator:a7b0db77f2d0178f08d9db4d25750fd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de83d8cbea30290aab3c7eee772049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a84de83d8cbea30290aab3c7eee772049">default_idle</a> ()</td></tr>
<tr class="memdesc:a84de83d8cbea30290aab3c7eee772049"><td class="mdescLeft">&#160;</td><td class="mdescRight">External user space default idle function (used in the case that idle_function is null in multitask_request)  <a href="multitask_8c.html#a84de83d8cbea30290aab3c7eee772049">More...</a><br /></td></tr>
<tr class="separator:a84de83d8cbea30290aab3c7eee772049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754f449056971915a16c171782ac13e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ab754f449056971915a16c171782ac13e">syscall_multitask_request</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_threads, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> stack_bytes, void *idle_function, <a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a> mpu_protect, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_locks)</td></tr>
<tr class="separator:ab754f449056971915a16c171782ac13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d12964e1e5738ec6721678b18f6b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a14d12964e1e5738ec6721678b18f6b2b">order_absolute_priorities</a> ()</td></tr>
<tr class="separator:a14d12964e1e5738ec6721678b18f6b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f0f782b4f394e88e777f77833eb2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a0b2f0f782b4f394e88e777f77833eb2e">syscall_thread_define</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> id, void *fn, void *arg, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> c, <a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> t)</td></tr>
<tr class="separator:a0b2f0f782b4f394e88e777f77833eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43f8ccc03ab91872f31b30444422a4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ac43f8ccc03ab91872f31b30444422a4d">validate_ceiling_id</a> ()</td></tr>
<tr class="separator:ac43f8ccc03ab91872f31b30444422a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc9ee772b1653c779ac03c6cc73b64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a9acc9ee772b1653c779ac03c6cc73b64">syscall_multitask_start</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> freq)</td></tr>
<tr class="separator:a9acc9ee772b1653c779ac03c6cc73b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e7f05531ce77a0eaeaf9986a1681ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a97e7f05531ce77a0eaeaf9986a1681ab">syscall_thread_id</a> ()</td></tr>
<tr class="separator:a97e7f05531ce77a0eaeaf9986a1681ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca0cb20d7a90459730e324d4e482cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a1ca0cb20d7a90459730e324d4e482cdc">syscall_thread_yield</a> ()</td></tr>
<tr class="separator:a1ca0cb20d7a90459730e324d4e482cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e4b23c571c2d9d179b4ba0b7900e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a866e4b23c571c2d9d179b4ba0b7900e6">syscall_thread_end</a> ()</td></tr>
<tr class="separator:a866e4b23c571c2d9d179b4ba0b7900e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fab2995bbed7e15135fc27ca47d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a359fab2995bbed7e15135fc27ca47d57">syscall_get_time</a> ()</td></tr>
<tr class="separator:a359fab2995bbed7e15135fc27ca47d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c45004b0a0a1c6421e48172dc7c95d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a0c45004b0a0a1c6421e48172dc7c95d9">syscall_thread_time</a> ()</td></tr>
<tr class="separator:a0c45004b0a0a1c6421e48172dc7c95d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88181cd9837806cda58242c3a12fc49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ab88181cd9837806cda58242c3a12fc49">syscall_thread_priority</a> ()</td></tr>
<tr class="separator:ab88181cd9837806cda58242c3a12fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754c1689a7e5276a2089a20f0463a7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a754c1689a7e5276a2089a20f0463a7e1">syscall_lock_init</a> (<a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> prio)</td></tr>
<tr class="separator:a754c1689a7e5276a2089a20f0463a7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499ff3d48a2ff684d62e45eb5ce345dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a499ff3d48a2ff684d62e45eb5ce345dc">syscall_lock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="separator:a499ff3d48a2ff684d62e45eb5ce345dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb893fb41e034375ed68df5b52b9a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#adfb893fb41e034375ed68df5b52b9a51">syscall_unlock</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *m)</td></tr>
<tr class="separator:adfb893fb41e034375ed68df5b52b9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8a6d27b56fad7c687915357337ccac3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtcb__t.html">tcb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a8a6d27b56fad7c687915357337ccac3d">user_threads</a> [<a class="el" href="thread_8h.html#a5747ce5beae65002b9ee2c4a4cf8c329">MAX_NUM_THREADS</a>+2] = { 0 }</td></tr>
<tr class="memdesc:a8a6d27b56fad7c687915357337ccac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of TCB's of threads specificed by user (the active thread will be at index num_user_threads - i.e. one more than the last defined user thread)  <a href="multitask_8c.html#a8a6d27b56fad7c687915357337ccac3d">More...</a><br /></td></tr>
<tr class="separator:a8a6d27b56fad7c687915357337ccac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7b71344d29c1a1eb33dcedd570f11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#afe7b71344d29c1a1eb33dcedd570f11a">num_user_threads</a></td></tr>
<tr class="memdesc:afe7b71344d29c1a1eb33dcedd570f11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads that the user specified initialized specified to run (cannot be greater than MAX_NUM_THREADS)  <a href="multitask_8c.html#afe7b71344d29c1a1eb33dcedd570f11a">More...</a><br /></td></tr>
<tr class="separator:afe7b71344d29c1a1eb33dcedd570f11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ae2cec55f1b89b2feec90fa920ef1e48c">num_active_threads</a> = 0</td></tr>
<tr class="memdesc:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads that are still active from what the user initially specified (once this hits 0 then the main thread is again scheduled)  <a href="multitask_8c.html#ae2cec55f1b89b2feec90fa920ef1e48c">More...</a><br /></td></tr>
<tr class="separator:ae2cec55f1b89b2feec90fa920ef1e48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a5cf4e2c768a73eaec2ffaa193b050b80">active_thread_index</a></td></tr>
<tr class="memdesc:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active index of the thread in user_thread.  <a href="multitask_8c.html#a5cf4e2c768a73eaec2ffaa193b050b80">More...</a><br /></td></tr>
<tr class="separator:a5cf4e2c768a73eaec2ffaa193b050b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de4813a04b35d0e889c32deba62359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a51de4813a04b35d0e889c32deba62359">global_timeslot_counter</a> = 0</td></tr>
<tr class="memdesc:a51de4813a04b35d0e889c32deba62359"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current timeslot that the scheduler is using (i.e. how many scheduling decisions have been made as a result of timer preemption)  <a href="multitask_8c.html#a51de4813a04b35d0e889c32deba62359">More...</a><br /></td></tr>
<tr class="separator:a51de4813a04b35d0e889c32deba62359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2115ccd92943e1b183dae612bb2a29"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a9d2115ccd92943e1b183dae612bb2a29">total_utilization</a> = 0</td></tr>
<tr class="memdesc:a9d2115ccd92943e1b183dae612bb2a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to maintain the current utilization of the scheduled tasks (used in admission control)  <a href="multitask_8c.html#a9d2115ccd92943e1b183dae612bb2a29">More...</a><br /></td></tr>
<tr class="separator:a9d2115ccd92943e1b183dae612bb2a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d70924b3a245b614d3b150a097ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a227d70924b3a245b614d3b150a097ac5">protection_status</a></td></tr>
<tr class="memdesc:a227d70924b3a245b614d3b150a097ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the memory protection mode for this round of tasks (memory protection regions will be repeatedly created for individual threads if equal to thread_protect - otherwise a single region covering all of the user stack space for user and kernel threads will be created)  <a href="multitask_8c.html#a227d70924b3a245b614d3b150a097ac5">More...</a><br /></td></tr>
<tr class="separator:a227d70924b3a245b614d3b150a097ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275005d5849e9f3f95cd318e073bad28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a275005d5849e9f3f95cd318e073bad28">user_locks</a> [<a class="el" href="thread_8h.html#a4736b40a365c5ea2579fbf37eeaac2db">MAX_USER_LOCKS</a>]</td></tr>
<tr class="memdesc:a275005d5849e9f3f95cd318e073bad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of locks for coordination between user threads.  <a href="multitask_8c.html#a275005d5849e9f3f95cd318e073bad28">More...</a><br /></td></tr>
<tr class="separator:a275005d5849e9f3f95cd318e073bad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af424a5e8583f9ff3795f8ec79211922a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#af424a5e8583f9ff3795f8ec79211922a">num_user_locks</a></td></tr>
<tr class="memdesc:af424a5e8583f9ff3795f8ec79211922a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of locks requested by the user application.  <a href="multitask_8c.html#af424a5e8583f9ff3795f8ec79211922a">More...</a><br /></td></tr>
<tr class="separator:af424a5e8583f9ff3795f8ec79211922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97ea800d90c5f2c81478f725be69b49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ad97ea800d90c5f2c81478f725be69b49">num_defined_locks</a> = 0</td></tr>
<tr class="memdesc:ad97ea800d90c5f2c81478f725be69b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of locks already defined by the user application (should not exceed num_user_locks)  <a href="multitask_8c.html#ad97ea800d90c5f2c81478f725be69b49">More...</a><br /></td></tr>
<tr class="separator:ad97ea800d90c5f2c81478f725be69b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123498dea62575b7d38c997864aeecb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a123498dea62575b7d38c997864aeecb3">global_priority_ceiling</a> = 0xFFFFFFFF</td></tr>
<tr class="memdesc:a123498dea62575b7d38c997864aeecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current priority ceiling for user tasks (i.e. the maximum priority ceiling for all currently held locks)  <a href="multitask_8c.html#a123498dea62575b7d38c997864aeecb3">More...</a><br /></td></tr>
<tr class="separator:a123498dea62575b7d38c997864aeecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2bd4f223a6174ea8aff14e4f44770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a51a2bd4f223a6174ea8aff14e4f44770">highest_priority_lock</a> = 0</td></tr>
<tr class="memdesc:a51a2bd4f223a6174ea8aff14e4f44770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of the lock that currently is dictating the global_priority_ceiling (i.e. the lock who set the current global priority ceiling equal to its priority ceiling)  <a href="multitask_8c.html#a51a2bd4f223a6174ea8aff14e4f44770">More...</a><br /></td></tr>
<tr class="separator:a51a2bd4f223a6174ea8aff14e4f44770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789a56d621057f7249eced42d4039fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a789a56d621057f7249eced42d4039fd9">preemption_flag</a> = 0</td></tr>
<tr class="memdesc:a789a56d621057f7249eced42d4039fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal for indiciating that a scheduling decision needs to be made from preemption (and not from an explicit yield - used for charging time units)  <a href="multitask_8c.html#a789a56d621057f7249eced42d4039fd9">More...</a><br /></td></tr>
<tr class="separator:a789a56d621057f7249eced42d4039fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7132dbbbf7340079823e8bbd725c083d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a7132dbbbf7340079823e8bbd725c083d">__thread_user_stacks_base</a></td></tr>
<tr class="memdesc:a7132dbbbf7340079823e8bbd725c083d"><td class="mdescLeft">&#160;</td><td class="mdescRight">External symbol for accessing base of thread user stacks (linker script symbol)  <a href="multitask_8c.html#a7132dbbbf7340079823e8bbd725c083d">More...</a><br /></td></tr>
<tr class="separator:a7132dbbbf7340079823e8bbd725c083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa967f471625f1f443e57d3435a64a3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#aa967f471625f1f443e57d3435a64a3b6">__thread_kernel_stacks_base</a></td></tr>
<tr class="memdesc:aa967f471625f1f443e57d3435a64a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">External symbol for accessing base of thread main stacks (linker script symbol)  <a href="multitask_8c.html#aa967f471625f1f443e57d3435a64a3b6">More...</a><br /></td></tr>
<tr class="separator:aa967f471625f1f443e57d3435a64a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e993843777e91f227d316dd0901c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#ae8e993843777e91f227d316dd0901c29">multitask_request_called</a> = 0</td></tr>
<tr class="memdesc:ae8e993843777e91f227d316dd0901c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean flag for determining if multitask request was called and successfully returned (used to make sure thread_define does not run unless multitask_request was already called)  <a href="multitask_8c.html#ae8e993843777e91f227d316dd0901c29">More...</a><br /></td></tr>
<tr class="separator:ae8e993843777e91f227d316dd0901c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aa72ba411ec250e64625ee8cefbece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a60aa72ba411ec250e64625ee8cefbece">thread_define_called</a> = 0</td></tr>
<tr class="memdesc:a60aa72ba411ec250e64625ee8cefbece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean flag for determining if thread_define was called at least once before multitask_start is called.  <a href="multitask_8c.html#a60aa72ba411ec250e64625ee8cefbece">More...</a><br /></td></tr>
<tr class="separator:a60aa72ba411ec250e64625ee8cefbece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1563304537682ec785a0148a4de7130b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a1563304537682ec785a0148a4de7130b">util_bound</a> []</td></tr>
<tr class="memdesc:a1563304537682ec785a0148a4de7130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMS tight bounds for admission control (used to see if a new task can be safely admitted in thread_define)  <a href="multitask_8c.html#a1563304537682ec785a0148a4de7130b">More...</a><br /></td></tr>
<tr class="separator:a1563304537682ec785a0148a4de7130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f72e8ab2ecd43977ec5897dae37081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#aa1f72e8ab2ecd43977ec5897dae37081">timer_wrap_around</a></td></tr>
<tr class="memdesc:aa1f72e8ab2ecd43977ec5897dae37081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this value on first syscall_multitask_start invocation to make sure it is initialized correctly.  <a href="multitask_8c.html#aa1f72e8ab2ecd43977ec5897dae37081">More...</a><br /></td></tr>
<tr class="separator:aa1f72e8ab2ecd43977ec5897dae37081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d2573d1051d504479d8861c94e8e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="multitask_8c.html#a59d2573d1051d504479d8861c94e8e8d">timer_wrap_comparison</a></td></tr>
<tr class="memdesc:a59d2573d1051d504479d8861c94e8e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this value to something other than 1 if more than one invocation of the SysTick timer handler is needed.  <a href="multitask_8c.html#a59d2573d1051d504479d8861c94e8e8d">More...</a><br /></td></tr>
<tr class="separator:a59d2573d1051d504479d8861c94e8e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of SVC handlers associated with multithreading. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4dd1e2f7f1c9da499a0a418f0b5b0495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd1e2f7f1c9da499a0a418f0b5b0495">&#9670;&nbsp;</a></span>active_thread_holds_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> active_thread_holds_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for determining if the current thread holds any locks. Returns a boolean value (0 false / 1 true) indicating if locks are held by the active thread at the point of invoking this function </p>

</div>
</div>
<a id="a84de83d8cbea30290aab3c7eee772049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84de83d8cbea30290aab3c7eee772049">&#9670;&nbsp;</a></span>default_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void default_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External user space default idle function (used in the case that idle_function is null in multitask_request) </p>
<p>External user space default idle function (used in the case that idle_function is null in multitask_request) </p>

</div>
</div>
<a id="a14d12964e1e5738ec6721678b18f6b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d12964e1e5738ec6721678b18f6b2b">&#9670;&nbsp;</a></span>order_absolute_priorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void order_absolute_priorities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns static priorities of tasks as the tasks are defined (i.e. create an absolute ordering from 0 to num_active_threads based on lower field / tie-breaking in favor of lower priority) Every additional task defined must require the previous ordering to be re-evaluated (since it is not known how the period/ID of the new task will compare to the previous ones). Performs insertion sort (basically) to determine the highest priority task. Would be more efficient to sort user_threads array based on period/ID, but with such a low number of threads this complexity seems acceptable (and requires the least amount of rewrites for creating the new priority system) The next smallest prioritiy number (starting at 0 through num_threads) is assigned to the thread with the lowest period (and in the even to a tie is given to the thread with the lowest ID) </p>

</div>
</div>
<a id="a016a482f23be8cd4f8ab1d328fdc45d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016a482f23be8cd4f8ab1d328fdc45d7">&#9670;&nbsp;</a></span>PendSV_C_Handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PendSV_C_Handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continues to service the PendSV interrupt after the assembly-level interrupt has finished. Accepts a pointer to a main stack frame with all needed information (expected to be called from the assembly-level PendSV_Handler which merely prepares the stack prior to this function being invoked). Performs the essential acts of context switching and runs the global scheduler. Returns a pointer to the new MSP of the task to be run (can restore context from this in the assembly handler) </p>

</div>
</div>
<a id="a25cde7ce3d60ab7047be78e3026af797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cde7ce3d60ab7047be78e3026af797">&#9670;&nbsp;</a></span>schedule_rms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> schedule_rms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scheduling policy using RMS that returns the index in the user_threads array of the next task to be scheduled. Sweeps through the user_threads array and determines the highest priority task (including the idle thread) that is ready to run. Also performs bookkeeping related to maintaining the number of scheduling cycles until a waiting task can be made ready again (i.e. only consider tasks that are ThreadReady but change thread from ThreadWaiting to ThreadReady when time_until_release = 0). Maintain periodic behavior by incrementing time_until_release by thread period every time it equals 0 and by decrementing remaining_work for every cycle the current task is scheduled (reset to computation time upon reaching 0). </p>

</div>
</div>
<a id="a359fab2995bbed7e15135fc27ca47d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359fab2995bbed7e15135fc27ca47d57">&#9670;&nbsp;</a></span>syscall_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A call to this function represents the time that a task occupied rather than the raw number of decisions made as a result of timer preemption. The counter is treated as the absolute source of truth and represents the time after multitask_start initially invokes the scheduler (so counter == 0 implies the scheduler is working on timeslot 0). Timeslot is only incremented when a systick timer interrupt fires (to keep global_timeslot_counter in time with the number of scheduling decisions). </p>

</div>
</div>
<a id="a499ff3d48a2ff684d62e45eb5ce345dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499ff3d48a2ff684d62e45eb5ce345dc">&#9670;&nbsp;</a></span>syscall_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking system call for a user application to request control of a lock. Locks requests are granted / denied according to the original priority ceiling protocol (see interior comments for details about what this implies). Will not return until the lock has been acquired. Since this syscall is blocking, it is guranteed that any thread will only be waiting on a maximum of 1 lock. </p>

</div>
</div>
<a id="a754c1689a7e5276a2089a20f0463a7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754c1689a7e5276a2089a20f0463a7e1">&#9670;&nbsp;</a></span>syscall_lock_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a>* syscall_lock_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if there is space to initialize a new mutex. If it can be accomodated, a new mutex from the free batch in user_locks is initialized, and its address is returned. The <code>prio</code> field is the thread ID of the user thread whose static priority should be set as highest_priority. There is no gurantee that this function will be called after thread define, so must validate the ID in multitask_start (i.e. before the thing is actually scheduled) </p>

</div>
</div>
<a id="ab754f449056971915a16c171782ac13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab754f449056971915a16c171782ac13e">&#9670;&nbsp;</a></span>syscall_multitask_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_multitask_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>stack_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a>&#160;</td>
          <td class="paramname"><em>mpu_protect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>num_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an error code if the allocated space of the request would be larger than 32kB of stack space (or if the number of threads exceeds 14) Otherwise, this implementation sets up the requested stacks by taking slices starting from the base addresses (i.e. stack pointer decreasing from the base_addr - growing down for each num_thread). Transforms the request <code>stack_bytes</code> into the next highest power of 2 (ceiling) so that the stacks stay well aligned and behaved. This transformation may result in a rejection of parameters if they are at (but not exactly at the limit) of stack space (i.e. would not be rejected without rounding). Also configures memory regions to prevent unwanted access according to <code>mpu_protect</code> policy. Additionally initializes empty <a class="el" href="structmutex__t.html">mutex_t</a> structs in the global <code>user_locks</code> (one empty struct per num_locks specified by user) </p>

</div>
</div>
<a id="a9acc9ee772b1653c779ac03c6cc73b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acc9ee772b1653c779ac03c6cc73b64">&#9670;&nbsp;</a></span>syscall_multitask_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_multitask_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the SysTick timer to fire with interrupts as fast as 1 second (a frequency of zero of implies that the scheduler is not-preemptive and will only be invoked through explicit). Starts the SysTick timer to begin counting down (with the scheduling decision being pended directly from the SysTick timer handler). This function call is not again scheduled until all other user threads have terminated (i.e. joins the threads) and stops the SysTick timer when all threads have terminated. </p>

</div>
</div>
<a id="a0b2f0f782b4f394e88e777f77833eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2f0f782b4f394e88e777f77833eb2e">&#9670;&nbsp;</a></span>syscall_thread_define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int syscall_thread_define </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs admission control and parameter validation on the inputted arguements. Overwrites the "dummy" TCB created in multitask_request with the parameter id, async function, and periodic data needed for scheduling. Returns a negative error code if the task cannot be safely accepted, but otherwise accepts the task and places it in an empty location in the user_threads array. </p>

</div>
</div>
<a id="a866e4b23c571c2d9d179b4ba0b7900e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866e4b23c571c2d9d179b4ba0b7900e6">&#9670;&nbsp;</a></span>syscall_thread_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_thread_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately invokes the scheduler and labels the current thread as having exited (i.e. will not be scheduled). The dead TCB for this thread will still exist in the user_threads array and can be overwritten with a new definition now that this TCB is defunct. Decrements the number of active threads to allow the scheduler to schedule the main thread if all others have ended. Also cleans up the <code>user_threads</code> array to allow non-defunct threads to take the place Additionally releases any locks which the ending thread may currently possess </p>

</div>
</div>
<a id="a97e7f05531ce77a0eaeaf9986a1681ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e7f05531ce77a0eaeaf9986a1681ab">&#9670;&nbsp;</a></span>syscall_thread_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ID field of the TCB for the currently running thread. </p>

</div>
</div>
<a id="ab88181cd9837806cda58242c3a12fc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88181cd9837806cda58242c3a12fc49">&#9670;&nbsp;</a></span>syscall_thread_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the static priority of the currently running task. This is determined by the period parameter (with a lower period indiciating a higher priorty) unless a special priority has been assigned manually (such as the case of the idle task or priority inheritance) </p>

</div>
</div>
<a id="a0c45004b0a0a1c6421e48172dc7c95d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c45004b0a0a1c6421e48172dc7c95d9">&#9670;&nbsp;</a></span>syscall_thread_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> syscall_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the active time for the current thread. The active time is the number of scheduling cycles that the thread has been running (i.e. number of times the thread has been scheduled) </p>

</div>
</div>
<a id="a1ca0cb20d7a90459730e324d4e482cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca0cb20d7a90459730e324d4e482cdc">&#9670;&nbsp;</a></span>syscall_thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_thread_yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manually pends the PendSV signal to immediately invoke the scheduler. Labels the current thread as waiting (i.e. not to be scheduled again until the start of the next period) Under current scheduler schemes, the thread could be immediately rescheduled if it is the only one remaining (or is it has the highest priority) </p>

</div>
</div>
<a id="adfb893fb41e034375ed68df5b52b9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb893fb41e034375ed68df5b52b9a51">&#9670;&nbsp;</a></span>syscall_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syscall_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>System call for unlocking the provided mutex <code>m</code> (opaque at user level). Since threads are only waiting on a maximum of 1 lock (from above) and unlocks occur immediately (unconditionally), all threads waiting on this lock can immediately move to the ready state to contend for it again (those unsuccessful will go back to the blocked state). Once unlocked, the current mutex has its num_blocked_threads and current_locker field reset (to keep state consistent). After the mutex is unlocked, the new highest_priority_lck is determined, and the new prioriy of the running task is potentially changed to inherit a higher priority task's priority if it is blocking on a lock held by the current thread. </p>

</div>
</div>
<a id="a838007cda3d9a850381803edca1a15b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838007cda3d9a850381803edca1a15b0">&#9670;&nbsp;</a></span>thread_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External user space declaration for making the svc call to thread_end (should be what is called when user space function end) </p>

</div>
</div>
<a id="a7b0db77f2d0178f08d9db4d25750fd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0db77f2d0178f08d9db4d25750fd1f">&#9670;&nbsp;</a></span>thread_function_define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_function_define </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that constructs a default user-level stack frame on the PSP to allow this thread to be cleanly scheduled (mirrors the contents of the stack frame as if this thread moved to handler execution). Sets registers to expecting default values based on the values of <code>fn</code> and arg<code>at</code>index` in user_threads. </p>

</div>
</div>
<a id="ac43f8ccc03ab91872f31b30444422a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43f8ccc03ab91872f31b30444422a4d">&#9670;&nbsp;</a></span>validate_ceiling_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> validate_ceiling_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for validating that all of the specified hightest locker IDs are valid in the <code>user_locks</code> array. If any ID is invalid / not present in the taskset, the call to multitask_start fails. Otherwise, the priority_ceiling field is populated with the static priority of the specified task </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa967f471625f1f443e57d3435a64a3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa967f471625f1f443e57d3435a64a3b6">&#9670;&nbsp;</a></span>__thread_kernel_stacks_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __thread_kernel_stacks_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>External symbol for accessing base of thread main stacks (linker script symbol) </p>

</div>
</div>
<a id="a7132dbbbf7340079823e8bbd725c083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7132dbbbf7340079823e8bbd725c083d">&#9670;&nbsp;</a></span>__thread_user_stacks_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __thread_user_stacks_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>External symbol for accessing base of thread user stacks (linker script symbol) </p>

</div>
</div>
<a id="a5cf4e2c768a73eaec2ffaa193b050b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf4e2c768a73eaec2ffaa193b050b80">&#9670;&nbsp;</a></span>active_thread_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> active_thread_index</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Active index of the thread in user_thread. </p>

</div>
</div>
<a id="a123498dea62575b7d38c997864aeecb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123498dea62575b7d38c997864aeecb3">&#9670;&nbsp;</a></span>global_priority_ceiling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> global_priority_ceiling = 0xFFFFFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current priority ceiling for user tasks (i.e. the maximum priority ceiling for all currently held locks) </p>

</div>
</div>
<a id="a51de4813a04b35d0e889c32deba62359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de4813a04b35d0e889c32deba62359">&#9670;&nbsp;</a></span>global_timeslot_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> global_timeslot_counter = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current timeslot that the scheduler is using (i.e. how many scheduling decisions have been made as a result of timer preemption) </p>
<p>The current timeslot that the scheduler is using since program start. </p>

</div>
</div>
<a id="a51a2bd4f223a6174ea8aff14e4f44770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2bd4f223a6174ea8aff14e4f44770">&#9670;&nbsp;</a></span>highest_priority_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a>* highest_priority_lock = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Address of the lock that currently is dictating the global_priority_ceiling (i.e. the lock who set the current global priority ceiling equal to its priority ceiling) </p>

</div>
</div>
<a id="ae8e993843777e91f227d316dd0901c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e993843777e91f227d316dd0901c29">&#9670;&nbsp;</a></span>multitask_request_called</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> multitask_request_called = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean flag for determining if multitask request was called and successfully returned (used to make sure thread_define does not run unless multitask_request was already called) </p>

</div>
</div>
<a id="ae2cec55f1b89b2feec90fa920ef1e48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cec55f1b89b2feec90fa920ef1e48c">&#9670;&nbsp;</a></span>num_active_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_active_threads = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of threads that are still active from what the user initially specified (once this hits 0 then the main thread is again scheduled) </p>
<p>Number of threads that are still active from what the user initially specified. </p>

</div>
</div>
<a id="ad97ea800d90c5f2c81478f725be69b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97ea800d90c5f2c81478f725be69b49">&#9670;&nbsp;</a></span>num_defined_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_defined_locks = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of locks already defined by the user application (should not exceed num_user_locks) </p>

</div>
</div>
<a id="af424a5e8583f9ff3795f8ec79211922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af424a5e8583f9ff3795f8ec79211922a">&#9670;&nbsp;</a></span>num_user_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_user_locks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of locks requested by the user application. </p>

</div>
</div>
<a id="afe7b71344d29c1a1eb33dcedd570f11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7b71344d29c1a1eb33dcedd570f11a">&#9670;&nbsp;</a></span>num_user_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> num_user_threads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of threads that the user specified initialized specified to run (cannot be greater than MAX_NUM_THREADS) </p>
<p>Number of active threads that the user specified (cannot be greater than MAX_NUM_THREADS) </p>

</div>
</div>
<a id="a789a56d621057f7249eced42d4039fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789a56d621057f7249eced42d4039fd9">&#9670;&nbsp;</a></span>preemption_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> preemption_flag = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal for indiciating that a scheduling decision needs to be made from preemption (and not from an explicit yield - used for charging time units) </p>
<p>Used for determining the source of the schedulign decision (asserted when scheduling is performed from systick timer) </p>

</div>
</div>
<a id="a227d70924b3a245b614d3b150a097ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227d70924b3a245b614d3b150a097ac5">&#9670;&nbsp;</a></span>protection_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a> protection_status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the memory protection mode for this round of tasks (memory protection regions will be repeatedly created for individual threads if equal to thread_protect - otherwise a single region covering all of the user stack space for user and kernel threads will be created) </p>

</div>
</div>
<a id="a60aa72ba411ec250e64625ee8cefbece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aa72ba411ec250e64625ee8cefbece">&#9670;&nbsp;</a></span>thread_define_called</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> thread_define_called = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean flag for determining if thread_define was called at least once before multitask_start is called. </p>

</div>
</div>
<a id="aa1f72e8ab2ecd43977ec5897dae37081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f72e8ab2ecd43977ec5897dae37081">&#9670;&nbsp;</a></span>timer_wrap_around</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> timer_wrap_around</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this value on first syscall_multitask_start invocation to make sure it is initialized correctly. </p>
<p>Reset this value on first syscall_multitask_start invocation to make sure it is initialized correctly.</p>
<p>Counts the number of times that the current SysTick execution has reached its reset value. </p>

</div>
</div>
<a id="a59d2573d1051d504479d8861c94e8e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d2573d1051d504479d8861c94e8e8d">&#9670;&nbsp;</a></span>timer_wrap_comparison</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="arm_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> timer_wrap_comparison</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this value to something other than 1 if more than one invocation of the SysTick timer handler is needed. </p>
<p>Set this value to something other than 1 if more than one invocation of the SysTick timer handler is needed.</p>
<p>Holds the number of times that the SysTick timer needs to wrap around before it actually handles the interrupt. </p>

</div>
</div>
<a id="a9d2115ccd92943e1b183dae612bb2a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2115ccd92943e1b183dae612bb2a29">&#9670;&nbsp;</a></span>total_utilization</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float total_utilization = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to maintain the current utilization of the scheduled tasks (used in admission control) </p>
<p>Maintain the utilization of the currently active task set (used in admission control) </p>

</div>
</div>
<a id="a275005d5849e9f3f95cd318e073bad28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275005d5849e9f3f95cd318e073bad28">&#9670;&nbsp;</a></span>user_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex__t.html">mutex_t</a> user_locks[<a class="el" href="thread_8h.html#a4736b40a365c5ea2579fbf37eeaac2db">MAX_USER_LOCKS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of locks for coordination between user threads. </p>

</div>
</div>
<a id="a8a6d27b56fad7c687915357337ccac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6d27b56fad7c687915357337ccac3d">&#9670;&nbsp;</a></span>user_threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtcb__t.html">tcb_t</a> user_threads[<a class="el" href="thread_8h.html#a5747ce5beae65002b9ee2c4a4cf8c329">MAX_NUM_THREADS</a>+2] = { 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of TCB's of threads specificed by user (the active thread will be at index num_user_threads - i.e. one more than the last defined user thread) </p>
<p>Array of TCB's of threads specificed by user. </p>

</div>
</div>
<a id="a1563304537682ec785a0148a4de7130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1563304537682ec785a0148a4de7130b">&#9670;&nbsp;</a></span>util_bound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float util_bound[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0.000, 1.000, .8284, .7798, .7568, .7435, .7348, .7286,</div>
<div class="line">    .7241, .7205, .7177, .7155, .7136, .7119, .7106, .7094</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>RMS tight bounds for admission control (used to see if a new task can be safely admitted in thread_define) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li><li class="navelem"><a class="el" href="multitask_8c.html">multitask.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
